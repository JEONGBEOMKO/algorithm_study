백트래킹을 통한 문제를 풀어봄

주어지는 입력을 보면 다음과 같앋. 
첫째 줄 : 수의 개수
둘째 줄 : 수
셋째 줄 : 덧셈, 뺄셈, 곱셈, 나눗셈 각각의 개수

셋 째 줄을 입력 받고, 각 연산자를 배열로 두어 수를 두면 되지 않나?
즉, 4칸의 배열에 가각 연산자의 개수를 입력하고, 반복문안에서 재귀호출을 해주는 것이다. 그리고 재귀호출 때 마다 해당 연산자인덱스를 1감소시키며 0이 된다면 다음 인덱스(연산자)로 넘어간다. 

int[] number;	//숫
int[] opertaor; //연산자 개

public static void dfs(int num, int idx) {
	for(int i = 0; i < 4 ; i++) {
	//연산자 개수가 1개 인상인 경우
	if(operator[i] > 0) {
		
		//해당 연산자를 1 감소 시킨다.
		operator[i]--;
		
		switch(i) {
		case 0 : dfs(num + number[idx], idx + 1); break;
		case 1 : dfs(num - number[idx], idx + 1); break;
		case 2 : dfs(num * number[idx], idx + 1); break;
		case 3 : dfs(num / number[idx], idx + 1); break;
		}
		
		//재귀호출이 종료되면 다시 해당 연산자 개수를 복구한다.
		operator[i]++;
		}
	}
}


----------------------------------------------------------------------------

2가지 방법을 사용하여 풀이한다.

알고리즘은 위에서 설명한 것을 보충하여 쓸 것이다. 전체적인 알고리즘은 같되, 입력의 방법만 바꾸어 성능 차이를
비교해보고자 한다. 

1. Scanner
2. BufferedReader

1.가장 기본적인 방법이라 할 수 있다.
앞서 알고리즘 설명에서 조건문은 작성하지 않았는데, 조건문은 간단하게 idx(인덱스이자 깊이를 의미)가 N이랑 같아지면 모든 
연산자를 사용했다는 의미이므로, 해당 값이 최댓값인지, 최솟값인지를 보고 해당 값을 교체해주면 된다.