- 첫 번째 접근 과정(sort()함수 이용)

정렬문제이니 제일 먼저 sort()함수를 이용해보도록한다. 그래서 vector를 사용해 sort를 하려고 했다.
그래서 열심히 헤더파일에 algorithm과 vector를 추가해줬고 코드를 짜고 문제없이 출력 값이 나옴

하지만 결과는 메모리 초과
-> 공간 복잡도에 문제가 있다고 생각하여 sort()풀이방식을 과감히 버림.
  수의 개수 N은 최대 10,000,000개이다. 입력값을 전부 저장하면 메모리가 남아나지 않는다.

- 두 번째 접근 과정(count 이용)

공간 복잡도, 메모리 초과가 나오지 않게 하기 위해 입력값을 전부 버린다. 그 대안으로 입력을 받을 때마다 배열에 count를 올려 기록

헤더파일을 전부 버리고 이중 for문을 통해 count를 구현

결과 시간 초과
-> for문은 O(N)의 시간 복잡도를 가진다. 하지만 반복문 두개를 겹쳐서 사용하면? O(N^2)의 시간 복잡도로 변하게 되고 그러 인해 TIMELIMIT에 걸린다.

- 세 번째 접근 과정

iot_base:sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);

두 번째 알고리즘 고찰 과정에서 구현한 코드에 위 코드를 추가해주어 시간 복잡도를 해결.

위 코드는 C와 C++의 표준 stream의 동기화를 끊는 역할을 한다.
CIN과 COUT의 속도가 높아진다.


2. 코드 풀이

iot_base:sync_with_stdio(false); // C 입출력 방식 사용제한
cin.tie(NULL); //앞에서 cout으로 출력을 한다면 출력전에 입력부터 진행

int arr[10001] = {0, };
int n;
cin >> n;

배열을 10000 크기만큼 선언과 동시에 0으로 초기화. 그리고 사용자에게 입력 횟수를 변수 n으로 통해 입력받는다.

for (int i = 0; i < n; i++)

{
    int input;
    cin >> input;
    arr[input]++;
}


사용자에게 n번만큼 값을 input값을 입력받는데 input 위치에 해당하는 배열의 값을 1씩 증가시킨다. 이렇게 되면 해당하는 배열의 값과 인덱스 값을 통해 어떠한 수가 얼마만큼 입력되었는지 확인 할 수 있다.

for (int i =1; i < 10001; i++)
{
    if (arr[i])
        for(int j = 0; j <arr[i]; j++)
        count << i << '\n';
}

배열을 전체 조회하는데 배열 요소의 값이 0인 것은 제외시키고 배열 요소의 값만큼 배열의 인덱스 값을 출력하면 해결된다.





